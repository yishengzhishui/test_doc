# 二分查找

## 二分法两种写法

1. 左闭右开区间 [left, right)

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums)
        while left < right:
            mid = left + (right-left)//2
            if nums[mid] == target:
                return mid 
            elif nums[mid] > target:
                right = mid
            else:
                left = mid+1
        return -1

```

2. 左右都是闭区间[left,right]

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums)-1
        while left <= right:
            mid = left + (right-left)//2
            if nums[mid] == target:
                return mid 
            elif nums[mid] > target:
                right = mid-1
            else:
                left = mid+1
        return -1
```

## 首个大于目标值的位置

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        # 初始二分查找范围为整个数组[0, n)
        left, right = 0, len(nums)
        # 找到首个大于target的值
        while left < right:
            mid = left + ((right - left) >> 1) # 获取中间值
            if nums[mid] > target:
                right = mid    # 找到一个大于target的值，暂存并在左半区间继续查找
            else:
                left = mid + 1 # 没有找到大于target的值，在右半区间继续查找
  
        return -1 if right == len(nums) else right  # 如果right没有更新，说明没有找到首个大于target的值，返回-1
```

## 首个大于等于目标值的位置

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        # 初始二分查找范围为整个数组[0, n)
        left, right = 0, len(nums)
        # 找到首个大于等于target的值
        while left < right:
            mid = left + ((right - left) >> 1) # 获取中间值
            if nums[mid] >= target:
                right = mid    # 找到一个大于等于target的值，暂存并在左半区间继续查找
            else:
                left = mid + 1 # 没有找到大于等于target的值，在右半区间继续查找
  
        return -1 if right == len(nums) else right  # 如果right没有更新，说明没有找到首个大于target的值，返回-1
```

## 最后小于目标值的位置

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        # 初始二分查找范围为整个数组[0, n)
        left, right = 0, len(nums)
        # 找到最后小于target的值
        while left < right:
            mid = left + ((right - left) >> 1)
            if nums[mid] < target:
                left = mid + 1  # 找到一个小于target的值，暂存并在右半区间继续查找更大的小于target的值
            else:
                right = mid    # 没有找到小于target的值，则在左半区间去寻找更小的数
  
        return left - 1    # left始终为暂存结果的后一位
```

## 最后小于等于目标值的位置

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        # 初始二分查找范围为整个数组[0, n)
        left, right = 0, len(nums)
        # 找到最后小于target的值
        while left < right:
            mid = left + ((right - left) >> 1)
            if nums[mid] <= target:
                left = mid + 1  # 找到一个小于target的值，暂存并在右半区间继续查找更大的小于target的值
            else:
                right = mid    # 没有找到小于target的值，则在左半区间去寻找更小的数
  
        return left - 1    # left始终为暂存结果的后一位
```

## 题目

### [35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

思路：

找到目标值或者返回按照顺序的插入吧位置

可以转化为：找到首个大于等于target的位置

### [74. 搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/)

思路：

整个数组矩阵是连续的

```python
m, n = len(matrix), len(matrix[0])
left, right = 0, m * n
while 循环的时候
num = matrix[mid // n][mid % n]
```

### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

思路：

1. 定义辅助函数，找到首个大于target的位置
2. 将num和num-1传入函数中，就可以得到target的开始结束位置

### [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

思路：

旋转数组：本来是升序数组，在某个位置发生旋转

二分查找，需要判断左半部分还是右半部分是有序的

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        # 二分查找
        # 0～mid不包含旋转，且target在此范围内：nums[0] <= target <= nums[mid] 时  向前规约
        # 0 - mid包含旋转，分两两种情况：1，target <= nums[mid] < nums[0] 时向前规约（target 在旋转位置到 mid 之间）；
        # 2，nums[mid] < nums[0] <= target 时向前规约（target 在 0 到旋转位置之间）；

        # 上述三种情况可以总结如下：
        # nums[0] <= target <= nums[mid]
                   # target <= nums[mid] < nums[0]
                             # nums[mid] < nums[0] <= target

        # (nums[0] <= target)， (target <= nums[mid]) ，(nums[mid] < nums[0])，
        # 现在我们想知道这三项中有哪两项为真（明显这三项不可能均为真（因为这三项可能已经包含了所有情况））
        # 所以我们现在只需要区别出这三项中有两项为真还是只有一项为真。
        # 使用 “异或” 操作可以轻松的得到上述结果（两项为真时异或结果为假，一项为真时异或结果为真

        # 换句话说就是： nums[mid] < nums[0]，nums[0] > target，target > nums[mid] 三项均为真或者只有一项为真时向后规约。

        if not nums: return -1
        size = len(nums)
        left, right = 0, size-1

        while left<=right:
            mid = (left+right)//2
            if nums[mid] == target:
                return mid

            # if (nums[left]>nums[mid])^(nums[left]>target)^(target>nums[mid]):
            #     left = mid+1
            # else:
            #     right = mid-1

            # 判断左半部分是否有序
            if nums[left] <= nums[mid]:
                if nums[left] <= target <= nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1
            else:
                if nums[mid] <= target <= nums[right]:
                    left = mid + 1
                else:
                    right = mid - 1
  
        return -1
```

### [153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)

```python
       # 二分查找

        # 找到最小值，mid与right比较，
        # 如果mid大，则说明mid到right之间一定发生了旋转，那么最小值在mid+1到right之间
        # 如果right大，说明mid到right之间是单调递增的，最小值会在 left到mid之间

        left, right = 0, len(nums)-1
        while left<right:
            mid = (left+right)//2
            if nums[mid]>nums[right]:
                left = mid+1
            else:
                right = mid
        return nums[left]
```

# 栈

## 题目

### [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)

思路：括号左右对应，遇到右括号就弹出stack, 判断是否是对应

```python
class Solution:
    def isValid(self, s: str) -> bool:
        # stack
        # 为了减少边界条件的判断，stack放入一个不相干的值
        # 以左括号为key，右括号为value

        stack, dic = ['?'], {'(':')', '[':']', '{':'}'}

        for i in s:
            if i in dic:
                stack.append(dic[i])
            else:
                if i != stack.pop():
                    return False

        return len(stack) == 1
```

### [155. 最小栈](https://leetcode.cn/problems/min-stack/)

思路：使用辅助栈，保证getMin快速得到数据

```python
class MinStack:

    def __init__(self):
        # 数据栈，用于存储元素
        self.data = []
        # 辅助栈，用于存储当前最小值
        self.helper = []

    def push(self, val: int) -> None:
        # 将元素入栈到数据栈
        self.data.append(val)
        # 如果辅助栈为空或者新元素小于辅助栈的栈顶元素，则将新元素入栈到辅助栈，否则将辅助栈的栈顶元素再次入栈
        if len(self.helper) == 0 or val < self.helper[-1]:
            self.helper.append(val)
        else:
            self.helper.append(self.helper[-1])

    def pop(self) -> None:
        # 弹出数据栈和辅助栈的栈顶元素
        if self.data:
            self.helper.pop()
            return self.data.pop()

    def top(self) -> int:
        # 返回数据栈的栈顶元素
        if self.data:
            return self.data[-1]

    def getMin(self) -> int:
        # 返回辅助栈的栈顶元素，即当前最小值
        if self.helper:
            return self.helper[-1]

```

### [394. 字符串解码](https://leetcode.cn/problems/decode-string/)

思路：

1. 如果是'[',则将当前的数字和字符串都放入栈中
2. 如果是'[',则将栈中数据弹出，更新解码结果
3. 遇到数字需要累加
4. 遇到字符，更新当前字符

```python
class Solution:
    def decodeString(self, s: str) -> str:
        # 初始化栈、当前解码结果和当前数字的累积值
        stack, res, multi = [], "", 0

        # 遍历字符串
        for c in s:
            # 处理左括号 '['
            if c == '[':
                # 将当前数字和解码结果入栈，然后重置当前解码结果和数字
                stack.append([multi, res])
                res, multi = "", 0
            # 处理右括号 ']'
            elif c == ']':
                # 弹出栈顶元素，获取数字和栈顶解码结果，更新当前解码结果
                cur_multi, last_res = stack.pop()
                res = last_res + cur_multi * res
            # 处理数字
            elif '0' <= c <= '9':
                # 更新当前数字的累积值
                multi = multi * 10 + int(c)
            # 处理其他字符（字母）
            else:
                # 直接添加到当前解码结果中
                res += c

        # 返回最终解码结果
        return res

```

### [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)

思路：需要下一个升温的日期

需要建立一个单调栈，栈内元素单调递减

当前value 大于栈内元素时，就是得到升温了，就弹出元素，记录index差值

```python
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        # 单调递减栈
        size = len(temperatures)
        stack = []
        result = [0] *size

        for key, value in enumerate(temperatures):
            # 当前value 大于栈内元素时，就是得到升温了，就弹出元素，记录index差值
            while stack and value> temperatures[stack[-1]]:
                temp = stack.pop()
                result[temp] = key-temp
            stack.append(key)
        return result
```

### [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

思路：

1. 建立单调栈，单调递增的，
2. 当栈不为空且当前柱子的高度小于栈顶柱子的高度时，说明找到右边界
3. 为了处理边界问题，stack加入初始值-1，height尾部加入0，方便处理剩余元素

```python
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:

        # stack, 类似于找左右边界，左边界在stack中
        # 传入栈的是元素的下标，但是保证这些元素是单调递增的 height[stack[-1]是栈中最大的元素
        # 遍历数组，如果heights[i] < heights[stack[-1]]，右边界找到(找到比栈顶元素小的数);
        # 一次遍历之后，需要考虑栈里的剩余元素的出栈，需要最后有一个最小的元素0，来帮助其他的元素出栈，所以heights.append(0)
        # 为了减少边界条件判断，stack有初始值[-1]

        # 初始化高度数组，最后添加一个高度为0的柱子，方便处理栈中剩余元素
        heights.append(0)
        # 获取数组长度
        size = len(heights)
        # 初始化单调递增栈，栈中存储的是柱子的下标
        stack = [-1]
        # 初始化最大面积
        result = 0

        # 遍历数组
        for i in range(size):
            # 当栈不为空且当前柱子的高度小于栈顶柱子的高度时，说明找到右边界
            while stack and heights[i] < heights[stack[-1]]:
                # 弹出栈顶元素，计算面积
                height = heights[stack.pop()]
                width = i - stack[-1] - 1
                result = max(result, height * width)

            # 将当前柱子的下标入栈
            stack.append(i)

        # 返回最大面积
        return result

```

# 堆

使用python的heapq

## 题目

### [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

思路：使用堆排序，然后弹出对应的元素

heapq 默认小顶堆

```python
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        hp = []
        for num in nums:
            heapq.heappush(hp, -num)
  
        for i in range(k-1):
            heapq.heappop(hp)
        return -heapq.heappop(hp)
```

### [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)

思路：counter得到出现频次，然后建立小顶堆，依次弹出元素

```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        # 统计 nums 中每个元素的出现次数
        dic = collections.Counter(nums)

        # 创建一个最小堆（heap），堆中每个元素是一个元组 (-value, key)，其中 value 是元素出现的次数，key 是元素本身
        hp = [(-value, key) for key, value in dic.items()]

        # 堆化，将列表 hp 转换为最小堆
        heapq.heapify(hp)

        # 初始化结果列表
        result = []

        # 从堆中弹出前 k 个元素，将它们添加到结果列表中
        for i in range(k):
            result.append(heapq.heappop(hp)[1])

        # 返回结果列表
        return result

```

# 贪心算法

## 题目

### [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)

思路 判断是否能够从数组第一个下标，跳到最后一个

1. 从头遍历，记录能够到的最远距离
2. 实时更新这个最远距离

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        # 从头开始跳， 记录当前能到的最远距离
        # 如果 碰到i > 最远距离，则失败，若能一直跳下去就成功了
        # 因为是依次遍历，这个需要保证max_reach是最大的，
        # max_reach = 0
        # for i in range(len(nums)):
        #     if i > max_reach:
        #         return False
        #     max_reach = max(max_reach, nums[i] + i)
  
        # return True

        # 从后向前
        # 最远可以到达的位置 >= reach时， reach可以向前移动
        # 当reach==0时，即从数组头部可以到达最后一个元素
        reach = len(nums) - 1

        for i in range(reach, -1, -1):
            if nums[i] + i >= reach:
                reach = i

#如果最终 reach 等于 0，说明能够到达起始位置
        return reach == 0
```

### [45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)

思路：肯定可以到底最后，但是需要计算多少步

1. 和上面类似，需要记录最远距离 max_reach
2. 需要记录当前 步数内 可以达到的最远距离 end
3. 当遍历时发现 i 超过end，意思需要跳跃（加步数）

```python
class Solution:
    def jump(self, nums: List[int]) -> int:
         # 贪心算法 从前往后
        # 从头开始跳， 记录当前能到的最远距离 max_reach
        # end 表示当前步数内能够到达的最远位置
        # max_reach 表示当前能够到达的最远位置，是在遍历数组时不断更新的变量。
        # 如果当前位置 i 超过了 end，说明需要进行一次跳跃。
        max_reach, end = 0, 0
        step = 0

        for i in range(len(nums)):
            if i > end:
                end = max_reach
                step += 1

            max_reach = max(nums[i] + i, max_reach)

        return step
```

### [763. 划分字母区间](https://leetcode.cn/problems/partition-labels/)

思路：为了满足同一个字母，只在一个片段中出现

尽量将同一个字母最后一次出现的位置作为片段的结束位置

```python
class Solution:
    def partitionLabels(self, S: str) -> List[int]:
        # 同一个字母只能出现在同一个片段中
        # 也就是说同一个字母 第一次出现和最后一次出现 必须在同一个片段
        dic = {s: index for index, s in enumerate(S)}   #存储某个字母对应地最后一个序号
        num = 0  #直接计数
        result = []
        j = dic[S[0]]  #当前片段的最后位置

        for i in range(len(S)):  #逐个遍历
            num += 1  #找到一个就加1个长度，表示当前片段长度
            if dic[S[i]] > j:  #如果最后位置比刚才的大，就更新最后位置
                j = dic[S[i]]
            if i == j:  #片段结束，当前位置和这个字母在字典里的最后位置是相同的
                result.append(num)  # 加入result
                num = 0 # 归0
        return result
```

# 动态规划

## 理论-背包问题

### 0-1背包

#### 问题：

有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。 **每件物品只能用一次** ，求解将哪些物品装入背包里物品价值总和最大。

**每一件物品其实只有两个状态，取或者不取**

#### 解题思路

**dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少** 。

1. 不放物品i:(当前物品i的重量超过背包能够负担的j，无法放入)，所以`dp[i][j]=dp[i-1][j]`
2. 放入物品i: `dp[i][j]=dp[i - 1][j - weight[i]] + value[i]`
3. 递推公式：

```python
dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])
```

4. 初始化

   * 如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0
   * dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。需要根据j和weight[0]判断：j < weight[0]的时候，dp[0][j] 应该是 0；j >= weight[0]时，dp[0][j] 应该是value[0]
5. 遍历顺序

**先遍历物品，后遍历背包重量更好理解**

```python
def test_2_wei_bag_problem1(weight, value, bagweight):
    # 二维数组
    dp = [[0] * (bagweight + 1) for _ in range(len(weight))]

    # 初始化
    for j in range(weight[0], bagweight + 1):
        dp[0][j] = value[0]

    # weight数组的大小就是物品个数
    for i in range(1, len(weight)):  # 遍历物品
        for j in range(bagweight + 1):  # 遍历背包容量
            if j < weight[i]:
                dp[i][j] = dp[i - 1][j]
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])

    return dp[len(weight) - 1][bagweight]
```

### 0-1背包 -滚动数组

滚动数组就是将上面的二维dp数组压缩

能够压缩需要满足条件：上层可以重复利用

1. dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。
2. dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i
3. 初始化，dp[0]就是0；如果value都是正的，那么不需要手动初始化，默认全是0就行，dp数组在推导的时候一定是取价值最大的数
4. 遍历的时候需要注意，只能先遍历物品
5. 遍历的时候，背包容量要从大到小，遍历；目的保证物品i只被放入一次。

例子：

> 物品0的重量weight[0] = 1，价值value[0] = 15如果正序遍历
>
> dp[1] = dp[1 - weight[0]] + value[0] = 15
>
> dp[2] = dp[2 - weight[0]] + value[0] = 30
>
> 此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。
>
> 为什么倒序遍历，就可以保证物品只放入一次呢？
>
> 倒序就是先算dp[2]
>
> dp[2] = dp[2 - weight[0]] + value[0] = 15 （dp数组已经都初始化为0）
>
> dp[1] = dp[1 - weight[0]] + value[0] = 15
>
> 所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。

```python
def test_2_wei_bag_problem1(weight, value, bagweight):
    # 创建一个一维数组dp，dp[j]表示在背包容量为j的情况下的最大价值
    dp = [0] * (bagweight + 1)

    # 初始化第一行，即只考虑第一件物品的情况
    for j in range(weight[0], bagweight + 1):
        dp[j] = value[0]

    # 从第二个物品开始遍历
    for i in range(1, len(weight)):
        # 从右往左遍历背包容量，更新dp数组
        for j in range(bagweight, weight[i] - 1, -1):
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i])

    # 返回dp数组中最后一个元素的值，即考虑所有物品在背包容量为bagweight时的最大价值
    return dp[bagweight]

```

### 完全背包问题

和0-1背包基本一致，区别就是物品可以被放很多次。

所以背包容量遍历的时候，从小到大遍历

```python
def test_2_wei_bag_problem1(weight, value, bagweight):
    # 创建一个一维数组dp，dp[j]表示在背包容量为j的情况下的最大价值
    dp = [0] * (bagweight + 1)

    # 初始化第一行，即只考虑第一件物品的情况
    for j in range(weight[0], bagweight + 1):
        dp[j] = value[0]

    # 从第二个物品开始遍历
    for i in range(1, len(weight)):
        # 从右往左遍历背包容量，更新dp数组
        for j in range(weight[i], bagweight+1):
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i])

    # 返回dp数组中最后一个元素的值，即考虑所有物品在背包容量为bagweight时的最大价值
    return dp[bagweight]
```

## 题目

### [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

思路：斐波拉契数列

每次可以爬 1阶或两阶

dp[i] = dp[i-1]+dp[i-2]

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        if n<3:
            return n

        dp=[0]*n
        dp[0]=1
        dp[1]=2
        for i in range(2,n):
            dp[i]=dp[i-1]+dp[i-2]

        return dp[-1]
```

### [746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)

思路：

1. **dp[i]的定义：到达第i台阶所花费的最少体力为dp[i]**
2. **可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]**

dp[i - 1] 跳到 dp[i] 需要花费 dp[i - 1] + cost[i - 1]。

dp[i - 2] 跳到 dp[i] 需要花费 dp[i - 2] + cost[i - 2]。

```python
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        dp = [0] * (len(cost) + 1)
        dp[0] = 0  # 初始值，表示从起点开始不需要花费体力
        dp[1] = 0  # 初始值，表示经过第一步不需要花费体力
  
        for i in range(2, len(cost) + 1):
            # 在第i步，可以选择从前一步（i-1）花费体力到达当前步，或者从前两步（i-2）花费体力到达当前步
            # 选择其中花费体力较小的路径，加上当前步的花费，更新dp数组
            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])
  
        return dp[len(cost)]  # 返回到达楼顶的最小花费

```

### [118. 杨辉三角](https://leetcode.cn/problems/pascals-triangle/)

思路：每个数是 左上方和右上方数字的和

1. 转换成数组，其实就是上一个行的 斜上方和正上方 的和
2. 初始化要注意，每行头尾都是1

```python
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        # 初始化一个空列表用于存储结果
        result = []

        # 遍历每一行
        for i in range(numRows):
            # 初始化当前行的列表
            row = [0] * (i + 1)

            # 第一个和最后一个元素为1
            row[0], row[-1] = 1, 1

            # 计算当前行的中间元素
            for j in range(1, i):
                row[j] = result[i - 1][j - 1] + result[i - 1][j]

            # 将当前行加入结果列表
            result.append(row)

        return result

```

### [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

思路：不能连续偷两家

1. dp[i] 是当前最高金额， 判断偷i-1或是偷i和i-2
2. dp[i] = max(dp[i-1], dp[i-2]+nums[i])

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        # DP: 1、重复子问题；2、状态的定义；3、DP方程
        # 不能偷连续两家
        # a[i][0,1]: 0:i偷， 1:i不偷
        # a[i][0] = max(a[i-1][0], a[i-1][1])
        # a[i][1] = a[i-1][0] + nums[i]

        # if not nums:
        #     return 0
  
        # size = len(nums)
        # dp = [[0, 0] for _ in range(size)]
        # dp[0][1] = nums[0]
  
        # for i in range(1, size):
        #     dp[i][0] = max(dp[i - 1][0], dp[i - 1][1])
        #     dp[i][1] = dp[i - 1][0] + nums[i]
        # return max(dp[-1][0], dp[-1][1])

        # 优化：不增加新的维度
        # a[i]: MAX Value，结果返回 max(a)
        # a[i] = max(a[i-1]+0, a[i-2]+nums[i]) 偷i-1或是偷i和i-2

        if not nums:
            return 0

        size = len(nums)
        if size==1:
            return nums[0]

        dp = [0 for _ in range(size)]
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])

        for i in range(2, size):
            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])

        return dp[-1]
```

### [213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)

思路：房屋围成一圈了，那就是第一家和最后一家只能偷1个

其他和198一样

1. 将198代码构造成一个辅助函数
2. 比较偷第1和最后一个，谁更高

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        # 有一个环
        # 第一家和最后一家，只能偷一家，其他的和198题目一致
        if not nums:
            return 0
        if len(nums)<=2:
            return max(nums)

        r1 = self.helper(nums[:-1])
        r2 = self.helper(nums[1:])
        return max(r1,r2)

    def helper(self, nums):
        size = len(nums)
        if size==1:
            return nums[0]

        dp = [0 for _ in range(size)]
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])

        for i in range(2, size):
            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])

        return dp[-1]
```

### [152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)

思路： 乘积最大的 非空连续子数组

1. 因为可能包含负数，所以要保留一个最小值(负负得正)
2. 在nums[i]<0时，最大值最小值交换

```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:

        # DP 因为存在负数，负负得正，所以需要维护一个最小值
        # dp[i][0]max, dp[i][1]min
        # 如果nums[i] < 0；dp[i][0]得到结果前需要dp[i-1][0], dp[i-1][1]交换数值；dp[i-1][0]就变成负的了
        # 因为dp中的数据是会随时改变的，需要维护一个最大乘积result值；dp[i-1][0]就变成负的了

        # if not nums:
        #     return 0
        # size = len(nums)

        # dp = [[0 for _ in range(2)] for _ in range(size)]
        # result = dp[0][1] = dp[0][0] = nums[0]
  
        # for i in range(1, size):
        #     # 如果当前元素为负数，交换最大值和最小值
        #     if nums[i] < 0:
        #         dp[i - 1][0], dp[i - 1][1] = dp[i - 1][1], dp[i - 1][0]
  
        #     dp[i][0] = max(dp[i - 1][0] * nums[i], nums[i])
        #     dp[i][1] = min(dp[i - 1][1] * nums[i], nums[i])
        #     result = max(result, dp[i][0])
        # return result

        # DP 本元素的结果只和前一个元素有关
        # 优化空间

        if not nums:
            return 0
        size = len(nums)
        result = imax = imin = nums[0]

        for i in range(1, size):
            # 如果当前元素为负数，交换最大值和最小值
            if nums[i] < 0:
                imax, imin = imin, imax

            imax = max(imax * nums[i], nums[i])
            imin = min(imin * nums[i], nums[i])
            result = max(result, imax)
        return result
```

### [674. 最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)

思路：最长的，连续的，递增 子序列

1. 只需要比较 nums[i] 和 nums[i-1]
2. **dp[i]：以下标i为结尾的连续递增的子序列长度为dp[i]**
3. dp[i] = dp[i-1]+1

```python
class Solution:
    def findLengthOfLCIS(self, nums: List[int]) -> int:
        # 连续递增
        # 比较比较nums[i]与nums[i - 1]
        # dp[i] = dp[i - 1] + 1

        if not nums: return 0
        dp = [1] * len(nums)
        for i in range(1,len(nums)):
            if nums[i] > nums[i - 1]:
                dp[i] = dp[i - 1] + 1
        return max(dp)
```

### [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

思路： 最长的 递增子序列

1. 和上面的区别就是 可以是不连续的
2. dp[i] 的值代表 nums 以 nums[i]结尾的最长递增子序列长度。
3. 因为是不连续的，所以需要另一个for循环不断的更新dp
4. 位置i的最长递增子序列 等于 j从0到i-1各个位置的最长递增子序列 + 1 的最大值。
5. 所以：if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        #dp[i] 的值代表 nums 以 nums[i]结尾的最长递增子序列长度。
        # 位置i的最长递增子序列 等于 j从0到i-1各个位置的最长递增子序列 + 1 的最大值。
        # 所以：if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);
        if not nums: return 0
        dp = [1] * len(nums)
        for i in range(1,len(nums)):
            for j in range(i):
                if nums[j] < nums[i]: # 如果要求非严格递增，将此行 '<' 改为 '<=' 即可。
                    dp[i] = max(dp[i], dp[j] + 1)
        return max(dp)
```

### [139. 单词拆分](https://leetcode.cn/problems/word-break/)

思路： 需要确认给的字符串是否可以拆分

1. dp[i] 意思长度为i的字符串s[0:i] 是否能拆成单词
2. i<j, dp[i]是true 然后 s[i:j]也是单词，则 dp[j]就是true

```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        #dp[i]：长度为i的s[0:i]子串是否能拆分成单词
        # i<j, dp[i]是true 然后 s[i:j]也是单词，则 dp[j]就是true
        # dp 长度为 len(str)+1
        # dp[0] = true

        n=len(s)
        dp=[False]*(n+1)
        dp[0]=True
        for i in range(n):
            for j in range(i+1,n+1):
                if dp[i] and (s[i:j] in wordDict):
                    dp[j]=True
        return dp[-1]

```

### [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)

思路：需要使用最少的硬币个数

1. dp[i]是凑齐价值为i的需要最少的硬币数
2. 那凑到amount，就是 dp[amount-coin]+1
3. 所以要选所有当中最小的

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        # 类比上楼梯问题，
        # dp[i]是凑齐价值为i需要的最少硬币数量
        # 首先将dp[i]设置为一个不可能的数
        # 想凑到amount，那么凑到amount-coins[i]时的硬币个数+1

        dp = [0] + [float('inf') for _ in range(amount)]
  
        for coin in coins:
            for i in range(coin, amount + 1):
                dp[i] = min(dp[i], dp[i - coin] + 1)
  
        if dp[-1] == float('inf'):
            return -1
        return dp[-1]
```

### [279. 完全平方数](https://leetcode.cn/problems/perfect-squares/)

思路： 使用完全平方数最少的

1. 和凑硬币类似
2. dp[i] = min(dp[i], dp[i-$nums[j]]+1)
3. 牛顿法得到最大的平方根

```python
class Solution:
    def numSquares(self, n: int) -> int:
        # 和凑硬币类似
        # dp[i] = min(dp[i], dp[i-$nums[j]]+1)
        # 先找的最小的sqrt, 然后按照凑硬币的方法

        # 初始化 res 为 n，表示要寻找的最小平方数和的边界
        res = n

        # 初始化 dp 列表，用于存储每个正整数对应的最小平方数和
        dp = [n + 1 for _ in range(n + 1)]
        dp[0] = 0  # 0 的最小平方数和为 0

        # 当 res 的平方大于 n 时，使用牛顿法逼近 res 的平方根，直到找到平方根接近 n 的边界
        while res * res > n:
            res = (res + n // res) // 2

        # 从 1 到 res 进行循环，表示考虑每个平方数作为可能的组成元素
        for e in range(1, res + 1):
            # 对于每个 e * e 开始到 n 的范围，计算 dp[i]
            for i in range(e * e, n + 1):
                # 更新 dp[i]，将其设为当前值和 dp[i - e * e] + 1 中的较小者
                dp[i] = min(dp[i], dp[i - e * e] + 1)

        # 最终，dp[-1] 就是 n 的最小平方数和
        return dp[-1]

```

### [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

思路：类比 0-1背包问题

1. 背包容量就是sum/2
2. weight 和 value 都是一样的
3. 也就是说 dp[i]本来是： 容量为i的包，背的物品的最大价值，转换到这个就是 总容量是i的包，背的最大重量是dp[i]，所以dp[i]<=i
4. 如果背包能够装满，说明找到了，dp[target]=target
5. 公式：dp[i]=max(dp[i], dp[i-nums[j]]+nums[j])

```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        if sum(nums) % 2 != 0:
            return False
        target = sum(nums) // 2
        dp = [0] * (target + 1)
        for num in nums:
            for j in range(target, num-1, -1):
                dp[j] = max(dp[j], dp[j-num] + num)
        return dp[-1] == target
```

### [1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/)

思路：0-1 背包问题

石头一起粉碎，得到最后最小可能重量

转化一下就是：将石头分成尽可能重量相等的两堆，然后一起粉碎，这样就喝上面的很像了，唯一区别就是最后的结果处理，需要sum-dp[-1]*2

1. dp[j]就是容量为j的包，能够装的最大重量

```python
class Solution:
    def lastStoneWeightII(self, stones: List[int]) -> int:
        total_sum = sum(stones)
        target = total_sum // 2
        dp = [0] * (target + 1)
        for stone in stones:
            for j in range(target, stone - 1, -1):
                dp[j] = max(dp[j], dp[j - stone] + stone)
        return total_sum - 2* dp[-1]
```

### [494. 目标和](https://leetcode.cn/problems/target-sum/)

思路，可以转化为背包问题

1. 所有使用'+'的元素和为 x，所有使用'-'的元素和就是 sum(nums)-x
2. 然后要求 x-（sum-x）=target，=> x=(target+sum)/2
3. 转化为装满 容量是x的背包
4. 边界条件 x是整数，所以 不能出现//2 向下取整的
5. dp[j]就是 填满这个容量j的包的方法数
6. 推导：只要搞到nums[i]，凑成dp[j]就有dp[j - nums[i]] 种方法。

> 例如：dp[j]，j 为5，
>
> * 已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 容量为5的背包。
> * 已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 容量为5的背包。
> * 已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 容量为5的背包
> * 已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 容量为5的背包
> * 已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 容量为5的背包
>
> 那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来

7. dp[j]+=dp[i-nums[i]]
8. 初始化，dp[0]=1,其他都初始化为0

```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        total_sum = sum(nums)  # 计算nums的总和
        if abs(target) > total_sum:
            return 0  # 此时没有方案
        if (target + total_sum) % 2 == 1:
            return 0  # 此时没有方案
        target_sum = (target + total_sum) // 2  # 目标和
        dp = [0] * (target_sum + 1)  # 创建动态规划数组，初始化为0
        dp[0] = 1  # 当目标和为0时，只有一种方案，即什么都不选
        for num in nums:
            for j in range(target_sum, num - 1, -1):
                dp[j] += dp[j - num]  # 状态转移方程，累加不同选择方式的数量
        return dp[target_sum]  # 返回达到目标和的方案数
```
