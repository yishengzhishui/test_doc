package leetcode

// 前缀和+hash
// 如果前缀cur-k所得到的值在字典中出现，即cur和 之前某一位的前缀和 之间的差等于k
// 当前前缀和的结果需要放入dic中
func subarraySum(nums []int, k int) int {
	// 定义变量
	cur, result := 0, 0

	// 使用 map 存储前缀和及其出现的次数
	dic := make(map[int]int)
	// 初始化，为了下方 dic[cur-k],cur=k 是，应该是1
	dic[0] = 1

	// 遍历数组
	for _, num := range nums {
		// 更新当前前缀和
		cur += num

		// 计算差值，并查找差值在 map 中出现的次数
		result += dic[cur-k]

		// 更新 map 中当前前缀和的次数
		dic[cur]++
	}

	// 返回结果
	return result
}

// 使用前缀和的核心思想在于寻找具有特定和的子数组。
//前缀和表示从数组的起始位置到当前位置的元素和。
//通过维护前缀和的累积，我们可以在 O(1) 的时间内计算任意子数组的和。
//
//详细解释如下：
//
//1. **前缀和的定义：** 对于数组 `nums`，定义前缀和数组 `prefixSum`，其中 `prefixSum[i]` 表示数组 `nums` 从索引 `0` 到 `i` 的元素和。
//
//   ```
//   prefixSum[i] = nums[0] + nums[1] + ... + nums[i]
//   ```
//
//2. **子数组和的计算：** 对于任意子数组 `[i, j]`，其和可以通过前缀和数组计算得出。
//
//   ```
//   subarraySum(nums[i:j]) = prefixSum[j] - prefixSum[i-1]
//   ```
//
//   这里需要注意的是，如果 `i` 为 `0`，则 `prefixSum[-1]` 为 `0`。
//
//3. **解决子数组和为 k 的问题：** 如果我们要找子数组的和为 `k`，可以将上述公式稍作变形。
//
//   ```
//   subarraySum(nums[i:j]) = prefixSum[j] - prefixSum[i-1] = k
//   ```
//
//   通过整理，我们可以得到：
//
//   ```
//   prefixSum[j] = prefixSum[i-1] + k
//   ```
//
//   换句话说，如果我们知道了某一位置 `j` 的前缀和，以及在之前的某个位置 `i-1` 的前缀和，
//  使得二者之差等于 `k`，那么从 `i` 到 `j` 的子数组和就是 `k`。
//
//4. **使用 Map 优化查找：** 我们使用 `map` 来存储前缀和及其出现的次数。
//在遍历数组时，对于每个位置 `j`，我们检查 `map[prefixSum[j] - k]` 是否存在，
//如果存在，则说明从某个位置 `i` 到 `j` 的子数组和为 `k`，并将这个次数累加到结果中。
//
//通过使用前缀和和 `map` 的结构，我们能够以线性的时间复杂度解决子数组和为 `k` 的问题，而不需要使用嵌套循环。这样的优化使得算法更加高效。
