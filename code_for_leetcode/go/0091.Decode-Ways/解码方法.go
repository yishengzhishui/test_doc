package leetcode

// 当s[i] != 0时，两种情况：
// 如果 s[i-1]s[i] <= 26, 则 dp[i] = dp[i-1] + dp[i-2]；
// 如果 s[i-1]s[i] > 26, 则 dp[i] = dp[i-1]
// 当s[i] == '0'：
// 如果 s[i-1]s[i] <= 26, 则 dp[i] = dp[i-2]

// dp[i] 定义成长度为 i 的前缀子串有多少种解码方法（以 s[i - 1] 结尾的前缀子串有多少种解法方法）；
// dp[0] 的值是用于后面状态值参考的，在 i == 1 的时候，dp[i] += dp[i - 1] 即 dp[1] += dp[0] ，这里就需要 dp[0] = 1 。

func numDecodings(s string) int {
	// 检查输入字符串是否为空
	if len(s) == 0 {
		return 0
	}

	size := len(s)
	// 创建一个数组 dp，用于存储解码方法的数量
	dp := make([]int, size+1)
	dp[0] = 1 // 初始化，空字符串有一种解码方法

	// 遍历字符串，计算解码方法的数量
	for i := 1; i <= size; i++ {
		// 如果当前字符不是 '0'，则将前一个位置的解码方法数量累加到当前位置
		if s[i-1] != '0' {
			dp[i] += dp[i-1]
		}
		// 如果不是第一个字符，且前两个字符组成的数字在 "10" 到 "26" 之间，
		// 则将再前一个位置的解码方法数量累加到当前位置
		if i != 1 && s[i-2:i] > "09" && s[i-2:i] < "27" {
			dp[i] += dp[i-2]
		}
	}

	return dp[size]
}
